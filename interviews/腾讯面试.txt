1、nginx配置文件删掉了，如何看它的请求日志（配置文件的信息）放在哪？
通过find命令，如find . -name "error.log" 查找日志文件在哪里

2、nginx如何做到重新加载不影响现有的业务？
nginx里面分master进程和worker进程，master进程负责加载nginx配置文件以及管理worker进程，worker进程负责接收并处理请求；
nginx在运行过程中修改了nginx.conf配置文件并重新加载，master会检测nginx配置文件是否正确；
如果配置文件是OK的，打开失败则回滚，成功会按照最新的配置启动新的worker进程，新的请求也会通过新的worker进程去处理；
而老的worker进程，在处理完之前的请求后，就会被kill掉

3、nginx进程间怎么通信的？
https://juejin.im/post/5dae57cbf265da5b5c09143f
1）信号：操作系统与nginx的master进程间的通信方式，如关闭nginx，更新nginx配置文件等；
2）套接字：nginx中master进程和worker进程间的通信方式，目前只有master进程向worker进程发数据，还未用于worker进程向master进程发数据
使用socketpair，master进程在fork子进程（worker进程）前，会调用socketpair方法，这样父子进程间就可以通过socket对进行通信；
socketpair有两个channel，一个channel读，一个channel写（nginx只会master写，worker读）
worker进程会将socket加入epoll中，这样worker进程在处理连接请求的时候也能处理master发送的数据
3）共享内存：worker进程间的通信，通过mmap创建一块内存共享区域，通过munmap释放共享内存区域，worker进程都可以进行读取

4、进程间有哪些通信方式？
https://zhuanlan.zhihu.com/p/104713463
1）匿名管道，半双工的通信方式，数据只能由单向流动，且只能在有血缘关系的进程间通信。父进程创建管道，成功后可以得到两个文件描述符，
fd[0]指向读端，fd[1]指向写段；fork出子进程后，子进程也有两个文件描述符，关闭父进程的读端，关闭子进程的写端；读端和写端都是阻塞的，且数据量有限
2）流管道，去除了1第一种限制，全双工通信；
3）命名管道，管道可命名，全双工且允许无血缘关系的进程进行通信；
4）消息队列：进程间通信时，一个进程将数据放到对应的消息队列里面，另一个进程去响应的消息队列里面取数据，过程是非阻塞的；
进程通信数据量较大和通信频繁的时候不适用，因为要数据拷贝
5）共享内存：两个进程间有一块共享的内存，在共享内存上进行读写
6）信号量：实现进程间的互斥和同步，保证进程安全
7）socket套接字：不同主机的进程可以进行通信

5、nginx为什么快？
https://www.ixigua.com/pseries/6763574810439057931_6773962385037197837/?logTag=oVPPZk7U681JUZDOihS4G
主要是因为nginx底层通过io多用复用模型实现的
io模型：
1）io阻塞模型，数据准备阶段和数据copy（内核态将数据拷贝到用户态）阶段都是阻塞的，cpu让出去；
2）io非阻塞模型，数据准备阶段通过不停地询问，非阻塞的，cpu可以做其他事，但数据copy阶段是阻塞的；
3）io多路复用模型，数据准备阶段和数据copy阶段都是阻塞的，是通过select、poll、epoll去监听的，并且可以同时监听多个文件描述符
4）信号驱动式IO模型
5）异步io模型，非阻塞的，数据copy完后向应用进程发送一个通知即可
io多路复用模型：
1）select，发现有文件描述符准备好数据了，返回通知，但不包括具体是哪一个文件描述符，所以select需要轮寻是哪个文件描述符的数据准备好了；
select监听文件描述符的数量有限，1024个
2）poll，实现跟select一样，没有数量限制
3）epoll，效率最高，哪个文件描述符准备好了，即告诉epoll具体是哪一个，这是基于事件驱动的，其实就是相当于在每个文件描述符上添加了回调函数

6、什么是僵尸进程？
1）僵尸进程（zombie），父进程创建子进程，子进程再创建子进程，子进程退出后，父进程应该调用wait()或者waitpid()方法取得进程的中止状态；
如果没有调用，那么子进程的进程描述符将一直在系统进程表中，系统资源表消耗殆尽则无法新建线程；
可以通过信号通知机制解决，子进程退出时发信号给父进程，父进程调用wait()完成状态收集；将僵尸进程变成孤儿进程；
2）孤儿进程，子进程还在运行，而父进程已经退出，这个时候子进程就叫孤儿进程；有init进程接管，作为这些孤儿进程的父进程，由init进程完成状态收集工作；

7、socket编程怎么判断数据是否读完了？
从输入流（inputstream）中读数据，通过一个byte数组装读出的数据，read方法返回读取的数据长度，如果为-1怎表示数据读取完毕了

8、HashMap在JDK1.7和JDK1.8的区别？
1）1.7中底层实现为数组+链表；1.8中实现为数组+链表+红黑树，即在链表的长度大于8时，会将链表的结构转换成红黑数的结构；
2）扩容resize时，1.7需要重新计算每个key的下标；1.8不需要重新计算，只需要判断hash值在新增的bit位中判断是0还是1，是0则下标位置不变，是1则下标位置+远数组长度；
3）扩容resize时，1.7链表的元素顺序会倒置；而1.8则不会；

9、ConcurrentHashMap在JDK1.7和JDK1.8的区别？
1）1.7采用分段+hash表+链表实现的；1.8采用CAS+synchronize+hash表+链表+红黑树实现的；
2）put时，1.7实现对每段加锁（段继承了reentrantLock）；而1.8会判断hash表下标位置为空，则通过CAS的方式实现插入；若不为空，则在当前下标位置的Node对象加锁（synchronize），实现插入；

10、求一个整数二进制格式1的个数？
1）首先，整数要分正数和负数，二进制中，首位为0的为正数，首位为1的为负数；
2）正数很简单，不停地跟1做与运算，求最后一位是1还是0，然后将正数右移一位，直到最后等于0；
3）负数的二进制格式为，正数的补码，首位为1；按照右移的算法，右移一位，负数高位补1，则会陷入无限的死循环；
4）最终，采用左移，左移低位补0；判断当前数是否小于0，小于0表示高位为1，计数加1，然后不停地左移，直到数字为0；